<!DOCTYPE html>
<html lang="ru">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Карта</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        touch-action: none;
        background: #000;
    }

    #container {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        position: relative;
    }

    #map {
        position: absolute;
        transform-origin: 0 0;
        will-change: transform;
        user-select: none;
        touch-action: none;
    }
</style>
</head>
<body>

<div id="container">
    <img id="map" src="map-big.jpg" alt="Map">
</div>

<script>
const container = document.getElementById("container");
const map = document.getElementById("map");

let posX = 0, posY = 0;
let targetX = 0, targetY = 0;

let lastTouchX = 0, lastTouchY = 0;
let isDragging = false;

let scale = 1;
let lastScale = 1;

let startDistance = 0;
let startMid = { x: 0, y: 0 };

// --- Ограничение выхода карты ---
function clampPosition() {
    const rect = container.getBoundingClientRect();
    const mapWidth = map.naturalWidth * scale;
    const mapHeight = map.naturalHeight * scale;

    const minX = Math.min(0, rect.width - mapWidth);
    const minY = Math.min(0, rect.height - mapHeight);

    targetX = Math.min(0, Math.max(minX, targetX));
    targetY = Math.min(0, Math.max(minY, targetY));
}

// --- Плавное обновление transform ---
function animate() {
    // плавное приближение к целевой позиции
    posX += (targetX - posX) * 0.25;
    posY += (targetY - posY) * 0.25;

    map.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// --- Расстояние ---
function distance(p1, p2) {
    return Math.hypot(p2.clientX - p1.clientX, p2.clientY - p1.clientY);
}

// --- Средняя точка ---
function midpoint(p1, p2) {
    return {
        x: (p1.clientX + p2.clientX) / 2,
        y: (p1.clientY + p2.clientY) / 2
    };
}

// --- Touch start ---
container.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    }

    if (e.touches.length === 2) {
        isDragging = false;
        startDistance = distance(e.touches[0], e.touches[1]);
        startMid = midpoint(e.touches[0], e.touches[1]);
        lastScale = scale;
    }
});

// --- Touch move ---
container.addEventListener("touchmove", (e) => {
    e.preventDefault();

    if (e.touches.length === 1 && isDragging) {
        const touch = e.touches[0];

        const dx = touch.clientX - lastTouchX;
        const dy = touch.clientY - lastTouchY;

        // накапливаем движение плавно
        targetX += dx;
        targetY += dy;

        clampPosition();

        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
    }

    if (e.touches.length === 2) {
        const dist = distance(e.touches[0], e.touches[1]);
        const zoom = dist / startDistance;

        const newScale = Math.min(4, Math.max(1, lastScale * zoom));

        const mid = midpoint(e.touches[0], e.touches[1]);

        // корректируем позицию при зуме
        targetX -= (mid.x - targetX) * (newScale / scale - 1);
        targetY -= (mid.y - targetY) * (newScale / scale - 1);

        scale = newScale;
        clampPosition();
    }
});

// --- Touch end ---
container.addEventListener("touchend", (e) => {
    if (e.touches.length === 0) isDragging = false;
});
</script>

</body>
</html>

